1. refs
 1.1 해시
  - 깃의 모든 작업은 SHA1 해시 값을 참조 
  - 생성한 모든 해시 값은 show 명령어로 확인
 1.2 역조회
  - rev-parse 명렁어로 포인터의 해시 값을 조회 
 1.3 참조 목록
  - 깃에서는 생성된 해시 값을 쉽게 참조할 수 있도록 refs 목록 생성 = .git/refs 폴더 안에 있음

2. reflog
 1.1 참조 기록
  - reflog : 사용된 포인터들의 기록
  - reflog는 시스템에서 정의한 며칠 간의 기록만 보관
  - git flog : reflog 기록 보기
 1.2 기간 확인
  - 커밋의 로그 기록 필터링
  - ex) git show master@{yesterday}

3. blame
 - 커밋의 메타 정보를 코드 라이별로 같이 결합해 출력
 - blame 명령어는 개별 파일에서만 동작 / 명령어 인자 값으로 개별 파일을 전달 
 3.1 옵션 활용
  - git blame -L 시작줄, 마지막줄 파일이름
  ex) git blame -L 2,3 index.html
  - [-e] : 사용자 이름 대신 이메일을 출력합니다
  - [-w] : 공백 문자를 무시합니다
  - [-M] : 같은 ㅍ ㅏ일 내에서 복사나 이동을 감지
  - [-C] : 다른 파일에서 이동이나 복사된 것을 감지할 수 있습니다.

4. replace
 - replace는 기존 커밋을 다른 커밋인 것처럼 변경하는 기능
 4.1 저장소 분리 
  1단계 : 저장소를 분리할 수 있게 새로운 브랜치 하나 생성
  2단계 : 1단계에서 원격 저장소를 등록한 사용한 별칭 확인
  3단계 : 1단계에서 생성한 브랜치를 원격 저장소로 푸시 
          원격 저장소로 전송되는 브랜치 이름을 다르게 지정해 전송
        ex) git push old worked:master
  4단계 : 분리를 하려면 가상의 임시 객체를 하나 생성해야함 -> commit-tree 명령어 사용     
   ex) echo "devide history" | git commit-tree a0eb63d^{tree} 
  5단계 : 생성된 임시 객체를 다른 커밋 객체와 리베이스해 병합
  6단계 : 분리 작업한 로컬 저장소를 origin 원격 저장소로 push
  7단계 : 분리된 두 원격 저장소 중에서 마지막에 작업한 커밋으로 원격 저장소 복제
  8단계 : 원격 저장소를 패치해 커밋들을 가져옴 => 수동으로 커밋을 변경해 병합하기 위해서
  9단계 : 이전 원격 저장소와 commit-tree를 이용해 분리 객체를 replace함
          ex) git replace [커밋hash값1] [커밋hash값2]

5. 가비지 콜렉트
 5.1 가비지
  - 가비지 : 동적인 언어에서 메모리를 관리하려고 생성한 개념
  - 여러 번 객체 생성과 변경 반복 시 연결고리가 없는 고립된 객체들이 생겨 비효율적인 자원 상태가 옴 
  - 고립된 객체들은 대표적으로 reset or rebase 등을 자주 할 때 발생
  - 깃은 연결 고리가 없는 객체들을 pack 파일 형태로 압축해 저장
 5.2 실행
  - 깃에서 내부적으로 가비지 정리가 필요하다고 생각했을 때, gc 명령어를 자동으로 실행
  - gc 명령어가 실행되면 오래된 객체들은 삭제하고 저장소 용량도 정리  
  - git gc --auto
 5.3 refs 압축
  - gc 명령어는 객체의 압축과 refs를 같이 처리
  - refs를 추가로 변경하면 압축한 packed-refs 값을 수정하지 않고 새로운 refs 파일을 생성
   => 압축한 이후 refs 파일이 2개가 되고, refs 파일이 여러 개 있으면 기본적으로 refs 안에 있는 파일을 먼저 찾고
      이후에 압축된 packed-refs 내용을 검색
 5.4 환경 설정
  - gc.reflogExpire : reflog가 보존되는 기간 설정 - default값 90일
  - gc.reflogExpireUnreachable : default값 30일
  - gc.aggressiveWindow : 창의 크기 결정 - default값 250
  - gc.aggressiveDepth : 압축에 사용되는 매개변수 - default값 50
  - gc.pruneExpire : 저장소에 쓰는 다른 프로세스와 동시에 실행될 때 손상 방지
  - gc.worktreePruneExpire : 유예 기간을 설정하기
  - gc.autopacklimit : 최대 압축 숫자를 제어

6. prune
  6.1 고립된 객체
   - prune : 고립된 객체를 정리하는 기능
    -> --hard 옵션을 사용해 리셋하더라도 내부적으로 생성한 객체를 물리적으로 삭제하지 않음
    -> 삭제한 후에도 이전의 커밋으로 직접 체크아웃할 수 있음
   - reset은 단지 객체 연결 고리를 해제해 끊긴 상태로 처리 / 이 커밋은 깃 내부 저장소에 고립된 객체로 남아있음 
  6.2 객체 정리
   - 리셋으로 객체까지 완벽하게 삭제하려면 prune 명렁어를 사용해야함
   - [--dry-run] : 실행하지 않고 작업할 내역만 출력
   - [--verbose] : 작업한 결과 출력
   - git prune --dry-run --verbose
   - 고립한다는 것은 어떤 명령어로도 해당 객체에 접근할 수 없어야한다는 의미
   - 깃은 참조된 모든 객체의 연결 고리를 reflog를 이중으로 기록 
    => reflog는 깃에서 참조된 모든 객체의 기록을 일정 기간 유지하는 역할 
    => 리셋 명령만으로는 객체와 연결한 모든 고리를 완벽히 제거 x
   - ex) git reflog expire --expire=now --expire-unreachable=now --all [지금 바로 reflog 삭제하기]
   - git prune --expire now -v : 완전 객체 삭제 실행
  6.3 원격 작업
   - git remote prune : 원격 저장소에 고립된 객체 정리 
   - git fetch --prune : 원격 저장소의 브랜치를 병합한 후 삭제 / 삭제된 원격 저장소의 브랜치는 더 이상 참조x

7. rerere
  7.1 동일한 충돌
   - rerere : reuse recorded resolution / 어떤 문제로 충돌 발생 시 이를 기록
              rerere 기능을 활성화하면, 깃은 충돌을 해결할 때마다 해결한 문제의 유형을 기록 
              기록한 유형의 문제가 재발생하면, 미리 기록한 해결 정보를 바탕으로 자동으로 적용
  7.2 활성화
   - git config rerere.enabled true
   - [--global] : 로컬의 전체 저장소에 모두 적용하고자 한다면 사용              
   - git rerere status : 충돌 발생 시 어떤 파일들이 충돌했는 지 확인
   

